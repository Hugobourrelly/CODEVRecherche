# -*- coding: utf-8 -*-
"""
Created on Wed May 24 08:22:46 2023

@author: hugob
"""
import numpy as np

def indiceMinimumLocalVersGauche(X,i,largeur):
    """Part de l'indice i et cherche a sa gauche l'indice du 
    premier minimum local de
    sorte que pour tout k€[0,largeur] X[miniInd]<X[miniInd-k]"""
    miniInd=i
    compteur=0
    ind=i
    while compteur<largeur and ind>=0:
        compteur+=1
        if X[ind]<X[miniInd]:
            miniInd=ind
            compteur=0
        ind=ind-1
    return miniInd
            
def indiceMinimumLocalVersDroite(X,i,largeur):
    """Part de l'indice i et cherche a droite l'indice du premier
    minimum local de
    sorte que pour tout k€[0,largeur] X[miniInd]<X[k+miniInd]"""
    n=len(X)
    miniInd=i
    compteur=0
    ind=i
    while compteur<largeur and n>ind:
        compteur+=1
        if X[ind]<X[miniInd]:
            miniInd=ind
            compteur=0
        ind=ind+1
    return miniInd

def indiceMaximumLocalVersDroite(X,i,largeur):
    """Part de l'indice i et cherche a droite l'indice du premier
    maximum local de
    sorte que pour tout k€[0,largeur] X[maxInd]>X[k+miniInd]"""
    n=len(X)
    maxInd=i
    compteur=0
    ind=i
    while compteur<largeur and n>ind:
        compteur+=1
        if X[ind]>X[maxInd]:
            maxInd=ind
            compteur=0
        ind=ind+1
    return maxInd

                        
def secondPic(X,indice_ref,indice_res,largeurMin,largeurMax):
    """Détermine le maximum se trouvant entre le minimum local à droite de la fréquence
    de résonnance et le minimum local à gauche de la frequence de référence"""
    i1=indiceMinimumLocalVersDroite(X,indice_res,largeurMin)
    i2=indiceMinimumLocalVersGauche(X,indice_ref,largeurMin)
    if i1<i2:
        return True,X.index(max(X[i1:i2]))
    else:
        return False,0


def fenetrage2(X,Y,taille):
    """Cette fonction renvoie un vecteur réduit de X et Y
    sur une fenetre de largeur taille centré en max(X)"""
    X2=[abs(x) for x in X]
    (ind1,ind2)=((X2.index(max(X2))-int(taille/2)), (X2.index(max(X2))+int(taille/2)))
    if ind1<0:
        ind1=0
    return X[ind1:ind2],Y[ind1:ind2]

def calculDemiLargeurMiHauteur(Mod,Freq):
    """Calcule la demi largeur a mi hauteur DF, a gauche ou en droite,
    selon si le minimum du Module est atteint a droite ou à gauche 
    on le calcule a droite ou à gauche """
    n=len(Mod)
    maxi=max(Mod)
    indMax=Mod.index(maxi)    
    minADroite=min(Mod[indMax:])
    if minADroite==min(Mod):
        List=[abs(Mod[i]-maxi/2) for i in range(indMax,n)]
        ind=List.index(min(List))+indMax
        if Mod[ind]>maxi/2:
            coef_dir=np.longdouble(Mod[ind]-Mod[ind+1])/np.longdouble(Freq[ind]-Freq[ind+1])
            return 3**(-0.5)*((np.longdouble( maxi/(2) - Mod[ind] )/coef_dir) + Freq[ind]-Freq[indMax])
        else:
            coef_dir=np.longdouble(Mod[ind-1]-Mod[ind])/np.longdouble(Freq[ind-1]-Freq[ind])
            return 3**(-0.5)*((np.longdouble( maxi/2 - Mod[ind-1] )/coef_dir) + Freq[ind-1]-Freq[indMax])
        return Freq[ind]-Freq[indMax]
    else:
        List=[abs(Mod[i]-maxi/2) for i in range(indMax)]
        ind=List.index(min(List))
        if Mod[ind]>maxi/2: 
            coef_dir=np.longdouble(Mod[ind-1]-Mod[ind])/np.longdouble(Freq[ind-1]-Freq[ind])
            return 3**(-0.5)*(Freq[indMax]-(np.longdouble( maxi/(2) - Mod[ind-1] )/coef_dir) - Freq[ind-1])
        else:
            coef_dir=np.longdouble(Mod[ind]-Mod[ind+1])/np.longdouble(Freq[ind]-Freq[ind+1])
            return 3**(-0.5)*(Freq[indMax]-(np.longdouble( maxi/(2) - Mod[ind] )/coef_dir) - Freq[ind])
        return Freq[indMax]-Freq[ind]



  